# leetcode_hero

This app makes solving leetcode problems a fun adventure.

## Story Design Architecture Method

This project uses the story driven approach to design systems ensuring documentation is provided with proper context, examples, and other factors along with the code.

This approach is inspired by Donald Knuth's Literate Programming but updated for modern audiences.

## Story

This is the story of how a hero goes about creating a magic spell able to conquer the treacherous world known as leetcode.

Our hero forges a console to navigate the realm of code.
Each command is a spell, each file a quest.
The console narrates progress, guards against confusion,
and ensures that every journey begins and ends with clarity.

- [ ] TODO: ordinary world: Establish setting, characters (users, system), status quo.
- [ ] TODO: call to adventure: The problem/opportunity disrupts the status quo.
- [ ] TODO: (Often within Call to Adventure): Hesitation, fear, or initial failed solutions.
- [ ] TODO: meeting mentor: Introduction to tools, principles, or wisdom (e.g., a new algorithm, uv, best practices).
- [ ] TODO: crossing threshold: First real commitment—writing the first lines of the new solution.
- [ ] TODO: tests trials allies: Early challenges, debugging, finding helpful libraries/techniques.
- [ ] TODO: approach in most cave: Preparing for the core challenge—tackling the main algorithm's complexity.
- [ ] TODO: ordeal resurrection: The central crisis—a major bug, performance hurdle—faced and overcome.
- [ ] TODO: reward road back: Seizing the solution—it works! Initial refinement and validation.
- [ ] TODO: (Often part of Reward): Integrating the solution, dealing with consequences.
- [ ] TODO: (Often fused with Ordeal): Final test that proves the hero/solution has truly changed.
- [ ] TODO: return home: Solution is integrated; the world is improved; lessons are shared.
- [ ] TODO: new normal: Solution is integrated; the world is improved; lessons are shared.

## Story Framework

Inspired by literate programming (LP)

1. Narrate before coding “What does the reader need to understand next?” Keeps code readable.
2. Separate the actors “Who is responsible for this task?” Simplifies extension later.
3. Write one clear invariant per function “What must always be true?” Gives you correctness tests.
4. Design the UX for delight “What will make this satisfying to run?” Keeps motivation high.
5. Treat the CLI as your lab notebook “Can future-me replay this?” Builds reproducibility.
